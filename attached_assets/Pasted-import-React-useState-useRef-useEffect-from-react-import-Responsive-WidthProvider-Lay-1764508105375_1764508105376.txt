import React, { useState, useRef, useEffect } from 'react';
import { Responsive, WidthProvider, Layout } from 'react-grid-layout';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  Grid, 
  Smartphone, 
  Tablet, 
  Monitor,
  RotateCcw,
  Save,
  Eye,
  EyeOff
} from 'lucide-react';
import { cn } from '@/lib/utils';
import "react-grid-layout/css/styles.css";
import "react-resizable/css/styles.css";

const ResponsiveGridLayout = WidthProvider(Responsive);

export interface WidgetConfig {
  id: string;
  title: string;
  component: React.ReactNode;
  defaultSize: { w: number; h: number; minW?: number; minH?: number };
  category: 'trading' | 'data' | 'alerts' | 'analytics' | 'other';
  isVisible?: boolean;
  priority?: 'high' | 'medium' | 'low';
}

interface ResponsiveLayoutProps {
  widgets: WidgetConfig[];
  initialLayout?: { [key: string]: Layout[] };
  onLayoutChange?: (layouts: { [key: string]: Layout[] }) => void;
  onSaveLayout?: () => void;
  className?: string;
  isEditable?: boolean;
}

// Simplified responsive breakpoints
const BREAKPOINTS = {
  lg: 1200,   // Desktop 
  md: 996,    // Tablets / small desktop
  sm: 768,    // Large tablets
  xs: 480,    // Phones
  xxs: 0      // Small phones
};

// Simplified to 12 columns across ALL breakpoints for easier alignment
const COLS = {
  lg: 12,
  md: 12,
  sm: 12,
  xs: 12,
  xxs: 12
};

// Simple default layout generator - just place widgets in a basic grid
function generateDefaultLayouts(widgets: WidgetConfig[]): { [key: string]: Layout[] } {
  const visibleWidgets = widgets.filter(w => w.isVisible !== false);
  const layouts: { [key: string]: Layout[] } = {};
  
  // Desktop layout (lg) - use widget default sizes
  layouts.lg = [];
  let currentY = 0;
  let currentX = 0;
  
  visibleWidgets.forEach((widget, index) => {
    const w = Math.min(widget.defaultSize.w, 12); // Max 12 cols (full width)
    const h = widget.defaultSize.h;
    
    // If widget won't fit on current row, move to next row
    if (currentX + w > 12) {
      currentX = 0;
      currentY += h;
    }
    
    layouts.lg.push({
      i: widget.id,
      x: currentX,
      y: currentY,
      w: w,
      h: h,
      minW: widget.defaultSize.minW || 2,
      minH: widget.defaultSize.minH || 2
    });
    
    currentX += w;
  });
  
  // Medium layout (md) - use widget default sizes
  layouts.md = [];
  currentY = 0;
  currentX = 0;
  
  visibleWidgets.forEach((widget) => {
    const w = Math.min(widget.defaultSize.w, 12); // Max 12 cols (full width)
    const h = widget.defaultSize.h;
    
    if (currentX + w > 12) {
      currentX = 0;
      currentY += h;
    }
    
    layouts.md.push({
      i: widget.id,
      x: currentX,
      y: currentY,
      w: w,
      h: h,
      minW: widget.defaultSize.minW || 2,
      minH: widget.defaultSize.minH || 2
    });
    
    currentX += w;
  });
  
  // Small layout (sm) - single column mostly
  layouts.sm = [];
  currentY = 0;
  
  visibleWidgets.forEach((widget) => {
    const w = 12; // Full width
    const h = Math.max(3, Math.min(widget.defaultSize.h, 6));
    
    layouts.sm.push({
      i: widget.id,
      x: 0,
      y: currentY,
      w: w,
      h: h,
      minW: 6,
      minH: 2
    });
    
    currentY += h;
  });
  
  // Mobile layouts (xs, xxs) - single column, full 12-col grid for flexibility
  layouts.xs = [];
  layouts.xxs = [];
  currentY = 0;
  
  visibleWidgets.forEach((widget) => {
    const h = Math.max(3, Math.min(widget.defaultSize.h, 5));
    
    // xs layout - full width
    layouts.xs.push({
      i: widget.id,
      x: 0,
      y: currentY,
      w: 12,
      h: h,
      minW: 6,
      minH: 2
    });
    
    // xxs layout - full width
    layouts.xxs.push({
      i: widget.id,
      x: 0,
      y: currentY,
      w: 12,
      h: h,
      minW: 6,
      minH: 2
    });
    
    currentY += h;
  });
  
  return layouts;
}

// Merge saved layouts with default layouts to handle new widgets gracefully
function mergeLayouts(
  savedLayouts: { [key: string]: Layout[] } | undefined,
  defaultLayouts: { [key: string]: Layout[] },
  widgets: WidgetConfig[]
): { [key: string]: Layout[] } {
  if (!savedLayouts) {
    return defaultLayouts;
  }

  const visibleWidgetIds = widgets.filter(w => w.isVisible !== false).map(w => w.id);
  const merged: { [key: string]: Layout[] } = {};

  // For each breakpoint
  Object.keys(defaultLayouts).forEach(breakpoint => {
    const savedLayout = savedLayouts[breakpoint] || [];
    const defaultLayout = defaultLayouts[breakpoint] || [];

    // Create a map of saved layouts by widget ID
    const savedLayoutMap = new Map(savedLayout.map(l => [l.i, l]));

    // Start with saved layouts for existing widgets
    const mergedLayout: Layout[] = [];
    
    visibleWidgetIds.forEach(widgetId => {
      if (savedLayoutMap.has(widgetId)) {
        // Use saved layout
        mergedLayout.push(savedLayoutMap.get(widgetId)!);
      } else {
        // Widget is new, use default layout
        const defaultItem = defaultLayout.find(l => l.i === widgetId);
        if (defaultItem) {
          mergedLayout.push(defaultItem);
        }
      }
    });

    merged[breakpoint] = mergedLayout;
  });

  return merged;
}

export default function ResponsiveLayout({ 
  widgets, 
  initialLayout,
  onLayoutChange, 
  onSaveLayout,
  className,
  isEditable = false
}: ResponsiveLayoutProps) {
  const [currentBreakpoint, setCurrentBreakpoint] = useState<string>('lg');
  const [isDragging, setIsDragging] = useState(false);
  const [showLayoutInfo, setShowLayoutInfo] = useState(false);
  
  // Use ref to track if layouts have been initialized
  const layoutsInitialized = useRef(false);
  const [layouts, setLayouts] = useState<{ [key: string]: Layout[] }>(() => {
    layoutsInitialized.current = true;
    const defaultLayouts = generateDefaultLayouts(widgets);
    return mergeLayouts(initialLayout, defaultLayouts, widgets);
  });

  // Reload layouts when widgets or initialLayout change (tab switching)
  useEffect(() => {
    const defaultLayouts = generateDefaultLayouts(widgets);
    const mergedLayouts = mergeLayouts(initialLayout, defaultLayouts, widgets);
    setLayouts(mergedLayouts);
  }, [widgets, initialLayout]);

  const handleLayoutChange = (layout: Layout[], allLayouts: { [key: string]: Layout[] }) => {
    // Only update layouts if they've been initialized
    if (layoutsInitialized.current) {
      setLayouts(allLayouts);
      onLayoutChange?.(allLayouts);
    }
  };

  const resetLayouts = () => {
    const newLayouts = generateDefaultLayouts(widgets);
    setLayouts(newLayouts);
  };

  const getBreakpointIcon = (bp: string) => {
    switch (bp) {
      case 'xxs':
      case 'xs':
        return <Smartphone className="h-4 w-4" />;
      case 'sm':
      case 'md':
        return <Tablet className="h-4 w-4" />;
      default:
        return <Monitor className="h-4 w-4" />;
    }
  };

  const visibleWidgets = widgets.filter(w => w.isVisible !== false);

  return (
    <div className={cn("relative", className)}>
      {/* Layout Controls */}
      {isEditable && (
        <div className="flex items-center justify-between mb-4 p-2 bg-accent/10 border border-dashed border-primary/30 rounded-md">
          <div className="flex items-center gap-2">
            <Badge 
              variant="outline" 
              className="gap-2"
              data-testid="badge-current-breakpoint"
            >
              {getBreakpointIcon(currentBreakpoint)}
              <span className="uppercase font-mono text-xs">
                {currentBreakpoint}
              </span>
              <span className="text-muted-foreground">
                {COLS[currentBreakpoint as keyof typeof COLS]} cols
              </span>
            </Badge>
            
            {isDragging && (
              <Badge variant="default" className="gap-1" data-testid="badge-arranging">
                <Grid className="h-3 w-3" />
                Arranging
              </Badge>
            )}
            <span className="text-xs text-muted-foreground ml-2">
              Drag headers to move â€¢ Drag corners to resize
            </span>
          </div>

          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={resetLayouts}
              className="gap-2 h-7"
              data-testid="button-reset-layout"
            >
              <RotateCcw className="h-3 w-3" />
              <span className="hidden sm:inline">Reset Defaults</span>
            </Button>

            {onSaveLayout && (
              <Button
                variant="default"
                size="sm"
                onClick={onSaveLayout}
                className="gap-2 h-7"
                data-testid="button-save-layout"
              >
                <Save className="h-3 w-3" />
                <span className="hidden sm:inline">Save Layout</span>
              </Button>
            )}
          </div>
        </div>
      )}

      {/* Responsive Grid Layout */}
      <div className={cn(isEditable ? "layout-editable" : "")}>
        <ResponsiveGridLayout
          className="layout"
          layouts={layouts}
          breakpoints={BREAKPOINTS}
          cols={COLS}
          rowHeight={50}
          onLayoutChange={handleLayoutChange}
          onBreakpointChange={setCurrentBreakpoint}
          onDragStart={() => setIsDragging(true)}
          onDragStop={() => setIsDragging(false)}
          onResizeStart={() => setIsDragging(true)}
          onResizeStop={() => setIsDragging(false)}
          isDraggable={isEditable}
          isResizable={isEditable}
          draggableHandle=".widget-drag-handle"
          resizeHandles={['se']} // Only show south-east handle for cleaner UI
          margin={[8, 8]}
          containerPadding={[0, 0]}
          useCSSTransforms={true}
          preventCollision={false} // Allow pushing
          compactType="vertical"
        >
          {visibleWidgets.map((widget) => (
            <div key={widget.id} className="h-full">
              {widget.component}
            </div>
          ))}
        </ResponsiveGridLayout>
      </div>
    </div>
  );
}